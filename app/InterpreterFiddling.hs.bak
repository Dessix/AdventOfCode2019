{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE ScopedTypeVariables #-}
module InterpreterFiddling where

import Control.Monad (when, unless)
import Control.Monad.Freer
import Control.Monad.Freer.Coroutine
import Control.Monad.Freer.Error
import Control.Monad.Freer.TH
import Control.Monad.Freer.State

-- import Data.OpenUnion
-- import qualified Data.OpenUnion.Internal (FindElem)
import Data.Vector (Vector)
import qualified Data.Vector as Vector
import Data.Function ((&))

import Debug.Trace
import Text.Printf

import Resultant


-- yield' :: (FindElem t r, Member (Yield a b) r) => a -> Eff r b
-- yield' x = send (inj . Yield x)

-- yield' :: Member (Yield a b) effs => a -> b -> Eff effs b
yield' x f = send (Yield x id)

-- yieldResultNoResponse' :: Member (Yield a ()) effs => a -> Eff effs ()
-- yieldResultNoResponse' x = yield' x ()

-- yieldInt :: Member (Yield Int ()) r => Int -> Eff r ()
-- yieldInt a = yield' @Int a ()
yieldInt a = yield' a ()


--runIntYieldAndResumeInternal :: (Data.OpenUnion.Internal.FindElem (Yield Int ()) r, Num b) => Eff r b
-- runIntYieldAndResumeInternal :: (Member (Yield Int ()) r) => Eff r Int
runIntYieldAndResumeInternal = do
    empty <- yieldInt 2
    return 3

runIntYieldAndResume :: (Member (Yield Int ()) r) => _
runIntYieldAndResume =
    let res = run $ runC runIntYieldAndResumeInternal in
    case res of
        Continue (a::Int) continue -> do
            traceM ("Received int " ++ (show a))
            case run $ runC (undefined) of
                Continue _ _ -> undefined
                Done res -> return res
        _ -> undefined

--t = runC $ yieldInt (4 :: Int)

